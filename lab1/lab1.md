﻿练习一：理解通过make生成执行文件的过程。1.操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)编译init.c，生成init.o+ cc kern/init/init.cgcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o编译stdio.c，生成stdio.o+ cc kern/libs/stdio.cgcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o编译readline.c，生成redline.o+ cc kern/libs/readline.cgcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o编译panic.c，生成panic.o+ cc kern/debug/panic.cgcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o编译kdebug.c，生成kdebug.o+ cc kern/debug/kdebug.cgcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o编译kmonitor.c，生成kmonitor.o+ cc kern/debug/kmonitor.cgcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o编译clock.c，生成clock.o+ cc kern/driver/clock.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o编译console.c，生成console.o+ cc kern/driver/console.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o编译picirq.c，生成picirq.o+ cc kern/driver/picirq.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o编译intr.c，生成intr.o+ cc kern/driver/intr.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o编译trap.c，生成trap.o+ cc kern/trap/trap.cgcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o编译vectors.S，生成vectors.o+ cc kern/trap/vectors.Sgcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o编译trapentry.S，生成trapentry.o+ cc kern/trap/trapentry.Sgcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o编译pmm.c，生成pmm.o+ cc kern/mm/pmm.cgcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o编译string.c，生成string.o+ cc libs/string.cgcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o编译printfmt.c，生成printfmt.o+ cc libs/printfmt.cgcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o接下来用ld合并目标文件(object) 和 库文件(archive),生成kernel程序+ ld bin/kernelld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o编译bootasm.S，生成bootasm.o+ cc boot/bootasm.Sgcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o编译bootmain.c，生成bootmain.o+ cc boot/bootmain.cgcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o编译sign.c，生成sign.o+ cc tools/sign.cgcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.ogcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign连接源文件与目标文件，生成bootblock程序生成+ ld bin/bootblockld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o其中关键的参数为	-m <emulation>  模拟为i386上的连接器	-nostdlib  不使用标准库	-N  设置代码段和数据段均可读写	-e <entry>  指定入口	-Ttext  制定代码段开始位置'obj/bootblock.out' size: 488 bytesbuild 512 bytes boot sector: 'bin/bootblock' success!最后将bootloader放入虚拟硬盘ucore.img中去生成一个有10000个块的文件，每个块默认512字节，用0填充dd if=/dev/zero of=bin/ucore.img count=10000把bootblock中的内容写到第一个块dd if=bin/bootblock of=bin/ucore.img conv=notrunc从第二个块开始写kernel中的内容dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？大小必须为512字节并且倒数第二个字节是0x55,倒数第一个字节是0xAA练习二：使用qemu执行并调试lab1中的软件1.从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行修改 lab1/tools/gdbinit,内容为:set architecture i8086target remote :1234在gdbinit中添加define hook-stopx/i $pcend可以强制反汇编当前指令执行make debug,在gdb中执行si可以单步执行和显示汇编指令2.在初始化位置0x7c00设置实地址断点,测试断点正常在tools/gdbinit结尾加上set architecture i8086  //设置当前调试的CPU是8086	b *0x7c00  	c          	x /2i $pc  	set architecture i386  执行make debugBreakpoint 2, 0x00007c00 in ?? ()=> 0x7c00:      cli   0x7c01:      cld3.从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较在tools/gdbinit结尾加上	b *0x7c00	c	x /10i $pc便可以在q.log中读到"call bootmain"前执行的命令	----------------	IN: 	0x00007c00:  cli    		----------------	IN: 	0x00007c01:  cld    	0x00007c02:  xor    %ax,%ax	0x00007c04:  mov    %ax,%ds	0x00007c06:  mov    %ax,%es	0x00007c08:  mov    %ax,%ss		----------------	IN: 	0x00007c0a:  in     $0x64,%al		----------------	IN: 	0x00007c0c:  test   $0x2,%al	0x00007c0e:  jne    0x7c0a		----------------	IN: 	0x00007c10:  mov    $0xd1,%al	0x00007c12:  out    %al,$0x64	0x00007c14:  in     $0x64,%al	0x00007c16:  test   $0x2,%al	0x00007c18:  jne    0x7c14		----------------	IN: 	0x00007c1a:  mov    $0xdf,%al	0x00007c1c:  out    %al,$0x60	0x00007c1e:  lgdtw  0x7c6c	0x00007c23:  mov    %cr0,%eax	0x00007c26:  or     $0x1,%eax	0x00007c2a:  mov    %eax,%cr0		----------------	IN: 	0x00007c2d:  ljmp   $0x8,$0x7c32		----------------	IN: 	0x00007c32:  mov    $0x10,%ax	0x00007c36:  mov    %eax,%ds		----------------	IN: 	0x00007c38:  mov    %eax,%es		----------------	IN: 	0x00007c3a:  mov    %eax,%fs	0x00007c3c:  mov    %eax,%gs	0x00007c3e:  mov    %eax,%ss		----------------	IN: 	0x00007c40:  mov    $0x0,%ebp		----------------	IN: 	0x00007c45:  mov    $0x7c00,%esp	0x00007c4a:  call   0x7d0d		----------------	IN: 	0x00007d0d:  push   %ebp其与bootasm.S和bootblock.asm中的代码相同。练习三:分析 bootloader 进入保护模式的过程。BIOS 将通过读取硬盘主引导扇区到内存,并转跳到对应内存中的位置执行 bootloader。请分析 bootloader 是如何完成从实模式进入保护模式的。首先清理环境，将flag和段寄存器清零,.code16	    cli	    cld	    xorw %ax, %ax	    movw %ax, %ds	    movw %ax, %es	    movw %ax, %ss打开A20地址线seta20.1:               # 等待8042键盘控制器不忙	    inb $0x64, %al      # 	    testb $0x2, %al     #	    jnz seta20.1        #		    movb $0xd1, %al     # 发送写8042输出端口的指令	    outb %al, $0x64     #		seta20.1:               # 等待8042键盘控制器不忙	    inb $0x64, %al      # 	    testb $0x2, %al     #	    jnz seta20.1        #		    movb $0xdf, %al     # 打开A20	    outb %al, $0x60     # 加载GDT的基地址	lgdt gdtdesc 切换到保护模式, 	    movl %cr0, %eax	    orl $CR0_PE_ON, %eax	    movl %eax, %cr0跳转到32位代码. 在32位代码中, bootloader重新设置保护模式下的段寄存器, 然后设置栈顶指针, 之后跳转到C代码 ljmp $PROT_MODE_CSEG, $protcseg.code32                                             protcseg:    # Set up the protected-mode data segment registers    movw $PROT_MODE_DSEG, %ax                           movw %ax, %ds                                       movw %ax, %es                                      movw %ax, %fs                                       movw %ax, %gs                                       movw %ax, %ss                                      movl $0x0, %ebp    movl $start, %esp    call bootmain练习四：分析bootloader加载ELF格式的OS的过程1.bootloader如何读取硬盘扇区的？//检查硬盘是否就绪（检查0x1F7的最高两位，如果是01，则跳出循环；否则等待）static void waitdisk(void) {while ((inb(0x1F7) & 0xC0) != 0x40)/* do nothing */;}static void readsect(void *dst, uint32_t secno) {// 等待磁盘准备就绪  waitdisk();  outb(0x1F2, 1); #count = 1   #读取一个扇区  outb(0x1F3, secno & 0xFF);        #要读取的扇区编号  outb(0x1F4, (secno >> 8) & 0xFF);  #用来存放读写柱面的低 8位字节    outb(0x1F5, (secno >> 16) & 0xFF);  #用来存放读写柱面的高 2位字节  outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);#用来存放要读/写的磁盘号及磁头号  outb(0x1F7, 0x20);    // 0x20命令，读取扇区  waitdisk();  insl(0x1F0, dst, SECTSIZE / 4);        //获取数据}2.bootloader是如何加载ELF格式的OS？void bootmain(void) {// 从硬盘读取第一页(读到内存的位置，大小，ELF文件偏移)readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);  // 通过幻数判断是否为合法的ELF文件if (ELFHDR->e_magic != ELF_MAGIC) {goto bad;}    #加载每个程序头表中的段 (ignores ph flags)//定义两个程序头表段                                      struct proghdr *ph, *eph; // ELF头部有描述ELF文件应加载到内存什么位置的描述表， // 先将描述表的头地址存在phph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);eph = ph + ELFHDR->e_phnum;//循环读每个段，将ELF文件中数据写入内存for (; ph < eph; ph ++) {readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);} //根据ELF头部的入口信息，找到内核入口((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();bad:                           //出现问题时的处理outw(0x8A00, 0x8A00);outw(0x8A00, 0x8E00);/* do nothing */while (1);}练习五：实现函数调用堆栈跟踪函数 ss:ebp指向的堆栈位置存储着caller的ebp，借此可以得到所有使用堆栈的函数ebpss:ebp+4指向caller调用时的eip，ss:ebp+8等是（可能的）参数。分析最深一层为：ebp:0x00007bf8 eip:0x00007d6e args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8     <unknow>: -- 0x00007d6d --汇编语言在调用C函数的时候，先将参数按照倒序压到栈里，然后压入返回地址，即call语句的下一条指令的地址，然后将ebp的值压入栈中，之后将esp的值赋给ebp，然后再调整eip的值为函数入口地址。练习六：完善中断初始化和处理1.中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？如中断向量表中一个表项struct gatedesc {}：将bit位相加共64bit为8字节；其第2-3字节是段选择子，0-1字节和6-7字节拼成位移。通过段选择子和段偏移量，就可以找到中断处理代码入口。