练习0 填写已有实验proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.calloc_proc函数中增加：proc->wait_state = 0;//初始化进程等待状态  proc->cptr = proc->optr = proc->yptr = NULL;//进程相关指针初始化  这两行代码主要是初始化进程等待状态、和进程的相关指针，例如父进程、子进程、同胞等等。因为这里涉及到了用户进程，自然需要涉及到调度的问题，所以进程等待状态和各种指针需要被初始化。do_fork函数中增加：assert(current->wait_state == 0);//确保当前进程正在等待set_links(proc);//将原来简单的计数改成来执行set_links函数，从而实现设置进程的相关链接第一行是为了确定当前的进程正在等待，第二行是将原来的计数换成了执行一个set_links函数，因为要涉及到进程的调度，所以简单的计数肯定是不行的。idt_init函数中增加：SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);////这里主要是设置相应的中断门trap_dispatch函数中增加：current->need_resched = 1;练习1: 加载应用程序并执行这一部分主要修改load_icode函数。load_icode函数主要用来被do_execve调用,将执行程序加载到进程空间（执行程序本身已从磁盘读取到内存中）,这涉及到修改页表、分配用户栈等工作。该函数主要完成的工作如下：1、调用 mm_create 函数来申请进程的内存管理数据结构 mm 所需内存空间,并对 mm 进行初始化;2、调用 setup_pgdir来申请一个页目录表所需的一个页大小的内存空间,并把描述ucore内核虚空间映射的内核页表(boot_pgdir所指)的内容拷贝到此新目录表中,最后让mm->pgdir指向此页目录表,这就是进程新的页目录表了,且能够正确映射内核虚空间;3、根据可执行程序的起始位置来解析此 ELF 格式的执行程序，并调用 mm_map函数根据 ELF格式执行程序的各个段(代码段、数据段、BSS段等)的起始位置和大小建立对应的vma结构，并把vma 插入到 mm结构中，表明这些是用户进程的合法用户态虚拟地址空间;4.根据可执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址,并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了;5.需要给用户进程设置用户栈,为此调用 mm_mmap 函数建立用户栈的 vma 结构,明确用户栈的位置在用户虚空间的顶端,大小为 256 个页,即1MB,并分配一定数量的物理内存且建立好栈的虚地址<-->物理地址映射关系;6.至此,进程内的内存管理 vma 和 mm 数据结构已经建立完成,于是把 mm->pgdir 赋值到 cr3 寄存器中,即更新了用户进程的虚拟内存空间,此时的 init 已经被 exit 的代码和数据覆盖,成为了第一个用户进程,但此时这个用户进程的执行现场还没建立好;7.先清空进程的中断帧,再重新设置进程的中断帧,使得在执行中断返回指令iret后,能够让 CPU转到用户态特权级,并回到用户态内存空间,使用用户态的代码段、数据段和堆栈,且能够跳转到用户进程的第一条指令执行,并确保在用户态能够响应中断;这里我们主要完成的是proc_struct结构中tf结构体变量的设置，因为这里我们要设置好tf以便于从内核态切换到用户态然后执行程序，所以这里tf_cs即代码段设置为USER_CS、将tf->tf_ds、tf->tf_es、tf->tf_ss均设置为USER_DS。 练习2: 父进程复制自己的内存空间给子进程这一部分的工作完整由do_fork函数完成，具体是调用copy_range 函数，需要补全copy_range函数。这个具体的调用过程是由do_fork函数调用copy_mm函数，然后copy_mm函数调用dup_mmap函数，最后由这个dup_mmap函数调用copy_range函数。在copy_range函数中增加代码：    void * kva_src = page2kva(page);//返回父进程的内核虚拟页地址      void * kva_dst = page2kva(npage);//返回子进程的内核虚拟页地址      memcpy(kva_dst, kva_src, PGSIZE);//复制父进程到子进程      ret = page_insert(to, npage, start, perm);//建立子进程页地址起始位置与物理地址的映射关系(prem是权限)这里就是调用一个memcpy将父进程的内存直接复制给子进程即可。练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现fork首先当程序执行fork时，fork使用了系统调用SYS_fork,而系统调用SYS_fork则主要是由do_fork和wakeup_proc来完成的。do_fork()完成的工作在lab4的时候已经做过详细介绍，这里再简单说一下，主要是完成了以下工作：1、分配并初始化进程控制块(alloc_proc 函数);2、分配并初始化内核栈(setup_stack 函数);3、根据 clone_flag标志复制或共享进程内存管理结构(copy_mm 函数);4、设置进程在内核(将来也包括用户态)正常运行和调度所需的中断帧和执行上下文(copy_thread 函数);5、把设置好的进程控制块放入hash_list 和 proc_list 两个全局进程链表中;6、自此,进程已经准备好执行了,把进程状态设置为“就绪”态;7、设置返回码为子进程的 id 号。而wakeup_proc函数主要是将进程的状态设置为等待，即proc->wait_state = 0，此处不赘述。exec当应用程序执行的时候，会调用SYS_exec系统调用,而当ucore收到此系统调用的时候，则会使用do_execve()函数来实现，因此这里我们主要介绍do_execve()函数的功能，函数主要时完成用户进程的创建工作，同时使用户进程进入执行。 主要工作如下：1、首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。2、接下来是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。之后就是调用load_icode从而使之准备好执行。（具体load_icode的功能在练习1已经介绍的很详细了，这里不赘述了）wait当执行wait功能的时候，会调用系统调用SYS_wait，而该系统调用的功能则主要由do_wait函数实现，主要工作就是父进程如何完成对子进程的最后回收工作，具体的功能实现如下：1、 如果 pid!=0，表示只找一个进程 id 号为 pid 的退出状态的子进程，否则找任意一个处于退出状态的子进程;2、 如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程设置执行状态为PROC_SLEEPING（睡眠），睡眠原因为WT_CHILD(即等待子进程退出)，调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤 1 处执行;3、 如果此子进程的执行状态为 PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程(即子进程的父进程)完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，它所占用的所有资源均已释放。exit当执行exit功能的时候，会调用系统调用SYS_exit，而该系统调用的功能主要是由do_exit函数实现。具体过程如下：1、先判断是否是用户进程，如果是，则开始回收此用户进程所占用的用户态虚拟内存空间;（具体的回收过程不作详细说明）2、设置当前进程的中hi性状态为PROC_ZOMBIE，然后设置当前进程的退出码为error_code。表明此时这个进程已经无法再被调度了，只能等待父进程来完成最后的回收工作（主要是回收该子进程的内核栈、进程控制块）3、如果当前父进程已经处于等待子进程的状态，即父进程的wait_state被置为WT_CHILD，则此时就可以唤醒父进程，让父进程来帮子进程完成最后的资源回收工作。4、如果当前进程还有子进程,则需要把这些子进程的父进程指针设置为内核线程init,且各个子进程指针需要插入到init的子进程链表中。如果某个子进程的执行状态是 PROC_ZOMBIE,则需要唤醒 init来完成对此子进程的最后回收工作。5、执行schedule()调度函数，选择新的进程执行。所以说该函数的功能简单的说就是，回收当前进程所占的大部分内存资源,并通知父进程完成最后的回收工作。系统调用首先罗列下目前ucore所有的系统调用如下表：SYS_exit        : process exit,                           -->do_exitSYS_fork        : create child process, dup mm            -->do_fork-->wakeup_procSYS_wait        : wait process                            -->do_waitSYS_exec        : after fork, process execute a program   -->load a program and refresh the mmSYS_clone       : create child thread                     -->do_fork-->wakeup_procSYS_yield       : process flag itself need resecheduling, -->proc->need_sched=1, then scheduler will rescheule this processSYS_sleep       : process sleep                           -->do_sleep SYS_kill        : kill process                            -->do_kill-->proc->flags |= PF_EXITING                                                                 -->wakeup_proc-->do_wait-->do_exit   SYS_getpid      : get the process's pid一般来说，用户进程只能执行一般的指令,无法执行特权指令。采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层，简化用户进程的实现。 根据之前的分析，应用程序调用的 exit/fork/wait/getpid 等库函数最终都会调用 syscall 函数,只是调用的参数不同而已（分别是 SYS_exit / SYS_fork / SYS_wait / SYS_getid ）当应用程序调用系统函数时，一般执行INT T_SYSCALL指令后，CPU 根据操作系统建立的系统调用中断描述符，转入内核态，然后开始了操作系统系统调用的执行过程，在内核函数执行之前，会保留软件执行系统调用前的执行现场，然后保存当前进程的tf结构体中，之后操作系统就可以开始完成具体的系统调用服务，完成服务后，调用IRET返回用户态，并恢复现场。这样整个系统调用就执行完毕了。