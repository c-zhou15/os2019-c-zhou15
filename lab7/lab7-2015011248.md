练习0：填写已有实验需填写文件：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.csche.c练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题基于信号量的代码我们可以认为，当多个进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明条件满足了）。为了发信号，需要使用一个称作信号量的特殊变量。为通过信号量s传送信号，信号量通过V、P操作来修改传送信号量。 接下来对代码分析。lab7和之前的lab6的总体步骤基本没有多大的变化，直到创建第二个内核线程init_main时，发现init_main函数多执行了一个check_sync函数。根据注释可以看到，该函数分为了两个部分，第一部分是实现基于信号量的哲学家问题,第二部分是实现基于管程的哲学家问题。 练习1要求分析基于信号量的哲学家问题，这里我们先只用看该函数的前半部分。 首先实现初始化了一个互斥信号量，然后创建了对应5个哲学家行为的5个信号量，并创建5个内核线程代表5个哲学家，每个内核线程完成了基于信号量的哲学家吃饭睡觉思考行为实现。philosopher_using_semaphore函数中核心是phi_take_forks_sema和phi_put_forks_sema两个函数，其中调用了_up函数和_down函数，分别对应着信号量的V,P操作。_up函数首先通过local_intr_save函数关闭中断，如果信号量对应的wait queue中没有进程在等待，直接把信号量的value加一，然后通过local_intr_restore函数开中断返回。如果有进程在等待且进程等待的原因是semophore设置的，则调用wakeup_wait函数将wait_queue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后通过local_intr_restore函数开中断返回。_down函数首先关掉中断，然后判断当前信号量的value是否大于0。如果是大于0，则表明可以获得信号量，故让value减一，并打开中断返回即可；如果小于0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除（此过程需要先关中断，完成后开中断）练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题要求首先掌握管程机制,然后基于信号量实现完成条件变量实现,然后用管程机制实现哲学家就餐问题的解决方案。管程，即定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作,这组操作能同步进程和改变管程中的数据。 管程相当于一个隔离区，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程,从而需要确保进程之间互斥。 管程主要由这四个部分组成1、管程内部的共享变量;2、管程内部的条件变量;3、管程内部并发执行的进程;4、对局部于管程内部的共享数据设置初始值的语句。所谓条件变量，即将等待队列和睡眠条件包装在一起，就形成了一种新的同步机制，称为条件变量。个条件变量CV可理解为一个进程的等待队列,队列中的进程正等待某个条件C变为真。每个条件变量关联着一个断言Pc。当一个进程等待一个条件变量,该进程不算作占用了该管程,因而其它进程可以进入该管程执行,改变管程的状态,通知条件变量CV其关联的断言Pc在当前状态下为真。因而条件变量两种操作如下： - wait_cv: 被一个进程调用,以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时,不被认为是占用了管程。 - 被一个进程调用,以指出断言Pc现在为真,从而可以唤醒等待断言Pc被满足的进程继续执行。管程中的条件变量cv通过执行wait_cv，会使得等待某个条件C为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行；而进入管程的某进程设置条件C为真并执行signal_cv时，能够让等待某个条件C为真的睡眠进程被唤醒，从而继续进入管程中执行。发出signal_cv的进程A会唤醒睡眠进程B，进程B执行会导致进程A睡眠，直到进程B离开管程，进程A才能继续执行，这个同步过程是通过信号量next完成的；而next_count表示了由于发出singal_cv而睡眠的进程个数。ucore设计实现了条件变量wait_cv操作和signal_cv操作对应的具体函数，即cond_wait函数和cond_signal函数，此外还有cond_init初始化函数。 对于cond_signal函数，首先进程B判断cv.count，如果不大于0，则表示当前没有睡眠的进程，因此就没有被唤醒的对象了，直接函数返回即可； 如果大于0，这表示当前有睡眠的进程A，因此需要唤醒等待在cv.sem上睡眠的进程A。由于只允许一个进程在管程中执行，所以一旦进程B唤醒了别人（进程A），那么自己就需要睡眠。故让monitor.next_count加一，且让自己（进程B）睡在信号量monitor.next上。如果睡醒了，这让monitor.next_count减一。对于cond_wait函数，可以看出如果进程A执行了cond_wait函数，表示此进程等待某个条件C不为真，需要睡眠。因此表示等待此条件的睡眠进程个数cv.count要加一。接下来会出现两种情况。 情况一：如果monitor.next_count如果大于0，表示有大于等于1个进程执行cond_signal函数且睡着了，就睡在了monitor.next信号量上。假定这些进程形成S进程链表。因此需要唤醒S进程链表中的一个进程B。然后进程A睡在cv.sem上，如果睡醒了，则让cv.count减一，表示等待此条件的睡眠进程个数少了一个，可继续执行。 情况二：如果monitor.next_count如果小于等于0，表示目前没有进程执行cond_signal函数且睡着了，那需要唤醒的是由于互斥条件限制而无法进入管程的进程，所以要唤醒睡在monitor.mutex上的进程。然后进程A睡在cv.sem上，如果睡醒了，则让cv.count减一，表示等待此条件的睡眠进程个数少了一个，可继续执行了！这样我们就可以在此基础上继续完成哲学家就餐问题的解决了，主要是就是如下的两个函数：phi_take_forks_condvar函数，phi_put_forks_condvar函数