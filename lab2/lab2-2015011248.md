练习0：填写已有实验使用meld工具，可以将不同目录的文件异同比较出来，将kdebug.c和trap.c手动合并。练习1：实现 first-fit 连续物理内存分配算法运行make qemu,出现kernel panic at kern/mm/default_pmm.c:238，说明在default_pmm.c的第238行出现错误。但此行在函数static void default_check(void)中，这是一个检查函数，并且提示不能修改。不过为了调试，也可以修改一点，例如cprintf输出的调试信息，还有check函数中使用大量的assert函数，大概是当参数条件不为1时弹出debug minitor，也可用来调试。之后查看可能的任务目标default_alloc_pages和default_free_pages函数，结合list_add函数发现它的空闲块插入顺序有问题：每次插入都是从free_list的头部插入，事实上应该保持free_list的顺序，地址小的空闲块应该放在前面，地址大的放在后面，以便firstfit算法从头快速查找。default_alloc_pages：主要就是从空闲页块的链表中去遍历，找到第一块大小大于n的块，然后分配出来，把它从空闲页链表中除去，然后如果有多余的，把分完剩下的部分再次加入会空闲页链表中即可。default_free_pages()：这个函数的作用是释放已经使用完的页，把他们合并到free_list中。先在free_list中找到合适的位置以供插入，然后改变被释放的页的标志位，以及头部的计数器，最后尝试在free_list中向搞地质或低地址合并。练习2：实现寻找虚拟地址对应的页表项这里需要实现get_pte函数，函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。pgdir给出页表起始地址。通过查找这个页表，我们需要给出二级页表中对应项的地址。 虽然目前我们只有boot_pgdir一个页表，但是引入进程的概念之后每个进程都会有自己的页表。若二级页表不存在，需要根据create参数的值来处理是否创建新的耳机页表。如果create参数为0，则get_pte返回NULL；如果create参数不为0，则get_pte需要申请一个新的物理页（通过alloc_page来实现），再在一级页表中添加页目录项指向表示二级页表的新物理页。当建立从一级页表到二级页表的映射时，需要注意设置控制位。这里应该设置同时设置 上PTE_U、PTE_W和PTE_P。如果原来就有二级页表，或者新建立了页表，则只需返回对应项的地址即可。练习3：释放某虚地址所在的页并取消对应二级页表项的映射思路主要就是先判断该页被引用的次数，如果只被引用了一次，那么直接释放掉这页， 否则就删掉二级页表的该表项，即该页的入口。