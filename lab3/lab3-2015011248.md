练习1：给未被映射的地址映射上物理页本实验要求完成do_pagfault函数，作用给未被映射的地址映射上的物理页具体而言，当启动分页机制后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等），就会发生页错误异常。产生页面异常的原因主要有：1.目标页面不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或已经撤销）2.相应的物理页面不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上）3.范文权限不符合（此时页表项P标志=1，比如企图写只读页面）当出现上面情况之一，就会产生页面异常page fault。产生异常的线性地址存储在CR2中，并且将是page fault的产生类型保存在error code中那么do_pgfault()函数就需要完成从CR2寄存器中获取页错误异常的虚拟地址，根据error code来查找这个虚拟地址是否在某个VMA的地址范围内，然后给它分配一个物理页。练习2：补充完成基于FIFO的页面替换算法根据练习1，当页错误异常发生时，有可能是因为页面保存在swap区或者磁盘文件上造成的，练习2需要利用页面替换算法解决这个问题。页面替换主要分为两个方面，页面换出和页面换入，页面换入由do_pgfault()函数实现，页面换出由swap_out_vistim()函数实现。换入已由练习1完成，接下来需要完成换出。FIFO替换算法会维护一个队列，队列按照页面调用的次序排列，越早被加载到内存的页面会越早被换出。_fifo_map_swappable()函数的主要作用是将最近被用到的页面添加到算法所维护的次序队列。然后是_fifo_swap_out_victim()函数是用来查询哪个页面需要被换出，它的主要作用是用来查询哪个页面需要被换出。最后可以看到check_vma_struct() succeeded!page fault at 0x00000100: K/W [no page found].check_pgfault() succeeded!check_vmm() succeeded.check_swap() succeeded!