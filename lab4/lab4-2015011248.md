练习0：填写已有实验需要修改default_pmm.cpmm.cswap_fifo.cvmm.ctrap.c练习1：分配并初始化一个进程控制块操作系统是以进程为中心设计的，所以其首要任务是为进程建立档案，进程档案用于表示、标识或描述进程，即进程控制块。这里需要完成的就是一个进程控制块的初始化。这里我们分配的是一个内核线程的PCB，它通常只是内核中的一小段代码或者函数，没有用户空间。而由于在操作系统启动后，已经对整个核心内存空间进行了管理，通过设置页表建立了核心虚拟空间(即boot_cr3指向的二级页表描述的空间)。所以内核中的所有线程都不需要再建立各自的页表，只需共享这个核心虚拟空间就可以访问整个物理内存了。练习2：为新创建的内核线程分配资源alloc_proc实质只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源，而练习2完成的do_fork才是真正完成了资源分配的工作，当然，do_fork也只是创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。 阅读源码，do_fork()完成的主要工作为：1.分配并初始化进程控制块（alloc_proc函数）2.分配并初始化内核栈（setup_stack 函数）3.根据 clone_flag标志复制或共享进程内存管理结构（copy_mm 函数）4.设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文 （copy_thread函数）5.把设置好的进程控制块放入hash_list 和proc_list 两个全局进程链表中6.自此,进程已经准备好执行了，把进程状态设置为“就绪”态7.设置返回码为子进程的 id号练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的查看schedule()函数，是一个FIFO调度器，执行过程如下：1.设置当前内核线程current->need_resched为02.在proc_list队列中查找下一个处于就绪态的线程或进程 next3.找到这样的进程后，就调用proc_run函数，保存当前进程current的执行现场(进程上下文)，恢复新进程的执行现场，完成进程切换。schedule函数通过查找proc_list进程队列,在这里只能找到一个处于就绪态的initproc内核线程。于是通过 proc_run和进一步的switch_to函数完成两个执行现场的切换。proc_run函数的执行过程为：1.让 current 指向 next 内核线程 initproc2.设置任务状态段 ts 中特权态0下的栈顶指针esp0为 next内核线程initproc的内核栈的栈顶，即 next->kstack + KSTACKSIZE 3.设置 CR3寄存器的值为next内核线程initproc的页目录表起始地址next->cr3，这实际上是完成进程间的页表切换4.由 switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当 switch_to函数执行完“ret”指令后，就切换到 initproc 执行了switch_to函数首先保存前一个进程的执行现场，即movl 4(%esp), %eax和popl 0(%eax)两行代码。然后保存前一个进程的其他7个寄存器到context中的相应域中。至此前一个进程的执行现场保存完毕。之后回复后一个进程的执行现场，是上述过程的逆过程。最后pushl 0(%eax)把 context 中保存的下一个进程要执行的指令地址 context.eip 放到了堆栈顶，样接下来执行最后一条指令“ret”时,会把栈顶的内容赋值给 EIP 寄存器，这样就切换到下一个进程执行了，即当前进程已经是下一个进程了，从而完成了进程的切换。然后回复向一个进程的执行现场，