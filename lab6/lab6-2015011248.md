练习0：填写已有实验修改文件：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.c修改alloc_proc()函数，对结构体proc_struct再增加：    proc->rq = NULL;//初始化运行队列为空    list_init(&(proc->run_link));//初始化运行队列的指针    proc->time_slice = 0;//初始化时间片    proc->lab6_run_pool.left = proc->lab6_run_pool.right proc->lab6_run_pool.parent = NULL; //初始化各类指针为空，包括父进程等待    proc->lab6_stride = 0;//步数初始化     proc->lab6_priority = 0;//初始化优先级修改trap_dispatch()函数,增加：    sched_class_proc_tick(current);     //注意，需要到kern/schedule/sched.c中将sched_class_proc_tick前的static去掉，否则会出现未定义错误练习1: 使用 Round Robin 调度算法Round Robin调度算法的调度思想是让所有 runnable 态的进程分时轮流使用 CPU 时间。Round Robin 调度器维护当前 runnable进程的有序运行队列。当前进程的时间片用完之后,调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。RR_init函数完成了对进程队列的初始化。RR_enqueue函数，首先把进程的进程控制块指针放到rq队列末尾，且如果进程控制块的时间片为0，则需要把它重置为max_time_slice。这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间。然后在依次调整rq和rq的进程数目加一。RR_dequeue函数将就绪进程队列rq的进程控制块指针的队列元素删除，然后就绪进程个数pro_num减一。RR_pick_next函数，选取就绪进程队列rq中的队头队列元素，把队列元素转换成进程控制块指针，即置为当前占用CPU的程序。RR_proc_tick函数，当时间片到时，当前执行进程的时间片time_slice便减一。如果time_slice降到零，则设置此进程成员变量need_resched标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量need_resched标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。 练习2: 实现 Stride Scheduling 调度算法这个算法将给每个进程控制块添加两个关键成员变量stride和priority，前者表示这个进程的调度权，后者表示这个进程的优先级。算法的基本思想如下：定义一个足够大的值BIG_STRIDE = 0x7FFFFFFF（为什么是0x7FFFFFFF将在文末给出解释），当一个进程调度后将在其调度权上加上一个步长即stride += BIG_STRIDE / priority（若优先级为0则直接加上BIG_STRIDE)每次需要调度时，从队列中选取调度权stride最小的进程进行调度可以证明由于每次选择stride最小的调度，且调度后加上BIG_STRIDE / priority，则优先级越高单次增加越小，被调度的次数也越多，即该算法为每个进程分配的时间与其优先级成正比。